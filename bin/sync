#!/usr/bin/env ruby
# frozen_string_literal: true

ENV["BUNDLE_GEMFILE"] ||= File.expand_path("../Gemfile", __dir__)

require "bundler/setup"
require "sshkit"
require "sshkit/dsl"
require "tty-spinner"
require "tty-prompt"
require "pastel"
require_relative "../lib/clawkit"

include SSHKit::DSL

PASTEL = Pastel.new

# Run a block with a spinner, return the block's result.
def spin(status_text)
  spinner = TTY::Spinner.new("[:spinner] #{status_text}", format: :dots, hide_cursor: true)
  spinner.auto_spin
  result = yield
  spinner.success
  result
rescue => e
  spinner.error
  raise
end

# Silence SSHKit logger during spinner phases to prevent log lines from breaking the output.
class NullOutput
  def <<(_); end
  def log_command_start(_); end
  def log_command_data(*, **); end
  def log_command_exit(_); end
end

def with_silent_sshkit
  old_output = SSHKit.config.output
  SSHKit.config.output = NullOutput.new
  yield
ensure
  SSHKit.config.output = old_output
end

Clawkit.load_env
config = Clawkit.load_config
ssh_user = config.fetch("ssh_user", "debian")
remote_path = config.fetch("remote_path")

abort "Error: Invalid remote_path: #{remote_path}" unless Clawkit.safe_path?(remote_path)

# Build unified list of sync items from directories: and files: config
sync_items = []

directories = config.fetch("directories", [])
directories.each do |dir|
  abort "Error: Invalid source for #{dir["name"]}: #{dir["source"]}" unless Clawkit.safe_path?(dir["source"])
  abort "Error: Invalid target for #{dir["name"]}: #{dir["target"]}" unless Clawkit.safe_path?(dir["target"])
  sync_items << dir.merge("type" => "directory")
end

files_config = config.fetch("files", nil)
if files_config == "*"
  # Wildcard: sync the whole remote_path as a directory
  sync_items << { "name" => "remote", "source" => "openclaw", "target" => ".", "type" => "directory" }
elsif files_config.is_a?(Array)
  files_config.each do |file|
    abort "Error: Invalid source for #{file["name"]}: #{file["source"]}" unless Clawkit.safe_path?(file["source"])
    abort "Error: Invalid target for #{file["name"]}: #{file["target"]}" unless Clawkit.safe_path?(file["target"])
    sync_items << file.merge("type" => "file")
  end
end

hosts = Clawkit.resolve_hosts(config)

# Filter items if names given as arguments
if ARGV.any?
  selected = sync_items.select { |a| ARGV.include?(a["name"]) }
  unknown = ARGV - sync_items.map { |a| a["name"] }
  abort "Error: Unknown item(s): #{unknown.join(", ")}\nAvailable: #{sync_items.map { |a| a["name"] }.join(", ")}" unless unknown.empty?
  sync_items = selected
end

abort "Error: Nothing to sync." if sync_items.empty?

# Use first host only
host = hosts.first
host_display = config.fetch("private_mode", false) ? "[REDACTED]" : host

puts "Syncing:  #{sync_items.map { |a| a["name"] }.join(", ")}"
puts "Host:     #{host_display}"
puts ""

SSHKit.config.default_env = {
  path: "/home/debian/.npm-global/bin:$PATH"
}

server = SSHKit::Host.new("#{ssh_user}@#{host}")

# Stop gateway before syncing
with_silent_sshkit do
  spin("Stopping openclaw gateway...") do
    on server do
      execute :openclaw, "gateway", "stop"
    end
  end
end

begin

openclaw_dir = File.join(Clawkit::PROJECT_DIR, "openclaw")

# Ensure openclaw git repo exists
unless Dir.exist?(File.join(openclaw_dir, ".git"))
  run_locally do
    execute :git, "-C", openclaw_dir, "init"
    execute :git, "-C", openclaw_dir, "add", "-A"
    execute :git, "-C", openclaw_dir, "commit", "-m", "'Initial commit'", raise_on_non_zero_exit: false
  end
end

# Auto-commit any pending local changes
run_locally do
  status = capture(:git, "-C", openclaw_dir, "status", "--porcelain")
  unless status.strip.empty?
    execute :git, "-C", openclaw_dir, "add", "-A"
    execute :git, "-C", openclaw_dir, "commit", "-m", "'Auto-commit before sync'"
  end
end

# Phase 1: Download all items
names = sync_items.map { |a| a["name"] }.join(", ")
with_silent_sshkit do
  spin("Downloading #{names}...") do
    sync_items.each do |agent|
      is_file = agent["type"] == "file"
      local_dir = File.join(Clawkit::PROJECT_DIR, agent["source"])
      remote_dir = "#{remote_path}/#{agent["target"]}"
      remote_spec = "#{ssh_user}@#{host}:#{remote_dir}#{is_file ? "" : "/"}"
      rsync_flags = is_file ? ["-lz"] : ["-rlz", "--delete"]
      local_spec = is_file ? local_dir : "#{local_dir}/"

      run_locally do
        execute :mkdir, "-p", is_file ? File.dirname(local_dir) : local_dir
        execute :rsync, *rsync_flags, "--checksum", remote_spec, local_spec
      end
    end
  end
end

# Phase 2: Check git status to categorize items
git_status = run_locally do
  capture(:git, "-C", openclaw_dir, "status", "--porcelain")
end

if git_status.strip.empty?
  puts PASTEL.green("[✔] #{names} in sync.")
else
  # Figure out which items have changes based on their source paths
  changed_files = git_status.lines.map { |l| l.strip }.reject(&:empty?)
  in_sync = []
  changed = []

  sync_items.each do |agent|
    source = agent["source"]
    # Strip the leading openclaw/ prefix to get relative path within the git repo
    rel = source.sub(%r{\Aopenclaw/}, "")
    is_file = agent["type"] == "file"

    has_changes = if is_file
      changed_files.any? { |f| f.end_with?(rel) }
    else
      changed_files.any? { |f| f.include?(rel) }
    end

    if has_changes
      changed << agent
    else
      in_sync << agent
    end
  end

  if in_sync.any?
    puts PASTEL.green("[✔] #{in_sync.map { |a| a["name"] }.join(" & ")} in sync.")
  end
  if changed.any?
    changed_count = changed_files.size
    puts PASTEL.yellow("[~] #{changed.map { |a| a["name"] }.join(" & ")} changed (#{changed_count} file(s))")
  end
  puts ""

  # Phase 3: Prompt for changed items
  prompt = TTY::Prompt.new
  loop do
    answer = prompt.select("Changes detected:", enum: ")") do |menu|
      menu.choice "See changes", :see
      menu.choice "Restart", :restart
      menu.choice "Upload", :upload
      menu.choice "Skip", :skip
    end

    case answer
    when :see
      system("code", openclaw_dir)
      next
    when :restart
      # Discard downloaded changes, re-download
      run_locally do
        execute :git, "-C", openclaw_dir, "checkout", "."
        execute :git, "-C", openclaw_dir, "clean", "-fd"
      end
      with_silent_sshkit do
        spin("Re-downloading #{agent["name"]}...") do
          run_locally do
            execute :rsync, *rsync_flags, "--checksum", remote_spec, local_spec
          end
        end
      end
      git_status = run_locally { capture(:git, "-C", openclaw_dir, "status", "--porcelain") }
      if git_status.strip.empty?
        puts PASTEL.green("[✔] #{agent["name"]} in sync.")
        break
      end
      file_count = git_status.lines.count { |l| !l.strip.empty? }
      puts "#{file_count} file(s) still changed."
      next
    when :upload
      changed.each do |agent|
        is_file = agent["type"] == "file"
        local_dir = File.join(Clawkit::PROJECT_DIR, agent["source"])
        remote_dir = "#{remote_path}/#{agent["target"]}"
        remote_spec = "#{ssh_user}@#{host}:#{remote_dir}#{is_file ? "" : "/"}"
        rsync_flags = is_file ? ["-lz"] : ["-rlz", "--delete"]
        local_spec = is_file ? local_dir : "#{local_dir}/"

        run_locally do
          execute :git, "-C", openclaw_dir, "add", "-A"
          execute :git, "-C", openclaw_dir, "commit", "-m", "'Sync: #{agent["name"]}'"
        end
        with_silent_sshkit do
          spin("Uploading #{agent["name"]}...") do
            on server do
              execute :mkdir, "-p", is_file ? File.dirname(remote_dir) : remote_dir
            end
            run_locally do
              execute :rsync, *rsync_flags, "--checksum", local_spec, remote_spec
            end
          end
        end
      end
      puts "  Done."
      break
    when :skip
      with_silent_sshkit do
        run_locally do
          execute :git, "-C", openclaw_dir, "checkout", "."
          execute :git, "-C", openclaw_dir, "clean", "-fd"
        end
      end
      puts "  Skipped."
      break
    end
  end

  puts ""
end

rescue Interrupt
  puts "\n  Aborted."
ensure
  # Always restart the gateway, even if interrupted
  with_silent_sshkit do
    spin("Starting openclaw gateway...") do
      on server do
        execute :openclaw, "gateway", "start"
      end
    end
  end
end

puts "[✔] Sync complete."
